---
title: "Pan-cancer_cell_line_heterogeneity"
author: "Daniel Hanhart"
date: "11/18/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(Seurat)
library(tidyverse)
library(liana)
library(RobustRankAggreg)
library(CellChat)
library(OmnipathR)
library(pals)
library(webr)
library(hash)
library(Nebulosa)
library(cluster)
library(intrinsicDimension)
################################################################################
## Functions  CellChat #########################################################
################################################################################

cellchat_wraper <- function(object, group_ident = "cell_line", assay = "RNA", slot = "data"){
    Idents(object) <- group_ident
   
    labels <- Seurat::Idents(object) ## in case the identities incluse 0, has to be renamed!
    meta <- data.frame(group = labels, row.names = names(labels))
    
    #cc <- createCellChat(GetAssayData(object, assay = assay, slot = slot), meta = meta, group.by = "group")
    cc <- createCellChat(object = GetAssayData(object, assay = assay, slot = slot), meta = meta, group.by = "group")
    CellChatDB <- CellChatDB.human
    cc@DB <- CellChatDB
    
    cc <- subsetData(cc)
    
    cc <- identifyOverExpressedGenes(cc)
    cc <- identifyOverExpressedInteractions(cc)
    
    cc<- computeCommunProb(cc, raw.use = TRUE, do.fast = TRUE, nboot = 100)
    cc <- filterCommunication(cc, min.cells = 1)
    df <- subsetCommunication(cc, thresh = 1)
    df$p.adj <- p.adjust(df$pval, "BH")
    
    return(df)
}


```


## R Markdown

```{r}

#sobj <- readRDS("/home/triller/Desktop/Projects/Pan-cancer_cell_line_heterogeneity/pan_cancer_heterogeneity/SERSI/run_all_samples/results/Pan_cancer/Annotation/scMRMA/SeuratObject.rds")
#saveRDS(sobj,file = "./../local/SeuratObject.rds")

sobj <- readRDS("./../local/SeuratObject.rds")

## add Cancer types to data
cancer_type_mapping <- readRDS("./../local/cancer_type_mapping.rds")
df_mapped <- data.frame(Cell_line = sobj@meta.data$cell_line)
df_mapped <- cbind(df_mapped, data.frame(ID = 1:nrow(df_mapped))) %>% merge(cancer_type_mapping, by = "Cell_line", all.x = TRUE, sort = FALSE ) %>% arrange(ID)
## doublecheck if still in the correct order?
table(df_mapped$Cell_line == sobj@meta.data$cell_line)
sobj@meta.data$Cancer_type <- df_mapped$Cancer_type



#sobj_sub <- subset(sobj, subset = Cancer_type == "Prostate Cancer")
#sobj_sub <- subset(sobj_sub, subset = pool_id == "22")
```




## overview of all the data

```{r}

DimPlot(sobj, group.by = "pool_id", reduction = "umap_RNA", label = FALSE)
DimPlot(sobj, group.by = "cell_line", reduction = "umap_RNA", label = FALSE) + theme(legend.position = "none")
DimPlot(sobj, group.by = "Cancer_type", reduction = "umap_RNA", label = FALSE)

```

## How do the cell cluster based on pools
 
The cells are analysed by their RNA assay and grouped based on their pool_id. 
recalculate the UMAP, to get a better representation of the subsamples

```{r}
# 
# pool_ids <- unique(sobj@meta.data$pool_id)
# 
# for(i in pool_ids){
#     print(i)
#     sobj_sub <- subset(sobj, subset = pool_id == i)
#     sobj_sub <- RunPCA(sobj_sub, assay = "RNA")
#     sobj_sub <- RunUMAP(sobj_sub, dims = 1:30, assay = "RNA", reduction = "pca")
#     print(DimPlot(sobj_sub, group.by = "Cancer_type", reduction = "umap", label = FALSE) + ggtitle(paste0("pool_", i)) )
# }
# theme(legend.position = "none")

```

## amount of cells by pool and cancer type

```{r}
metadata <- sobj@meta.data %>% group_by(pool_id, Cancer_type, cell_line) %>% summarise(nbr_of_cells = n())

p <- ggplot(metadata, aes(x = pool_id , y = nbr_of_cells, fill = Cancer_type )) +
    geom_bar(stat = "sum", position = "stack")  + theme_bw() + scale_fill_manual(values=c(kelly()[1:length(kelly())])) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
#    facet_grid(.~subtype, scale = "free", space = "free") + labs(title = lev)+ facet_grid(.~pool_id, drop = TRUE, scales = "free", space = "fixed")+ theme(legend.position = "none")
p

```

## amount of cells by cancer type

```{r}
metadata <- sobj@meta.data %>% group_by(pool_id, Cancer_type, cell_line) %>% summarise(nbr_of_cells = n())

p <- ggplot(metadata, aes(x = Cancer_type , y = nbr_of_cells, fill = Cancer_type )) +
    geom_bar(stat = "sum", position = "stack")  + theme_bw() + scale_fill_manual(values=c(kelly()[1:length(kelly())])) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + theme(legend.position = "none")
#    facet_grid(.~subtype, scale = "free", space = "free") + labs(title = lev)+ facet_grid(.~pool_id, drop = TRUE, scales = "free", space = "fixed")+ theme(legend.position = "none")
p

```


```{r, fig.width = 12, fig.height = 8}


DefaultAssay(sobj) <- "RNA"
 VlnPlot(sobj, features = "nCount_RNA", pt.size = 0, group.by = "pool_id", split.by = "Cancer_type")
 VlnPlot(sobj, features = "nFeature_RNA", pt.size = 0, group.by = "pool_id", split.by = "Cancer_type")
 VlnPlot(sobj, features = "mito_percent", pt.size = 0, group.by = "pool_id", split.by = "Cancer_type")




# features <- c("MDK", "NCL")
# DimPlot(sobj, group.by = "Cancer_type", reduction = "umap_integrated")
# Nebulosa::plot_density(sobj, features = features, reduction = "umap_integrated")
# 
# VlnPlot(sobj, features = features, group.by = "Cancer_type", pt.size = 0)

```


END

## try to subcluster for single cancer type before communication inference


```{r}
## Omnipather
library(OmnipathR)
## best tools based on https://genomebiology.biomedcentral.com/articles/10.1186/s13059-022-02783-y: c("CellChat","CellPhoneDB", "NicheNet", "ICELLNET")
ressources <- c("CellChatDB")
CellChatDB <- CellChatDB.human



net <- OmnipathR::import_intercell_network(ressources = ressources)
net_2 <- net %>% OmnipathR::filter_intercell_network(simplify = TRUE)

```

## SingleCellSingalR

```{r}
## get autocrine signalings
library(SingleCellSignalR)

DefaultAssay(sobj) <- "RNA"
## add cell line name alone to metadata
sobj@meta.data$Cell_line <- unlist(sapply(sobj@meta.data$cell_line,simplify = FALSE,USE.NAMES = FALSE, function(x){unlist(strsplit(x, split = "_"))[1]}))

cell_lines_by_cancer_type <- sobj@meta.data %>% select(Cancer_type, Cell_line) %>%group_by(Cancer_type) %>% summarise(Cell_lines = toString(unique(Cell_line), collapse = ","))

## replace cell line names with integer (necessary for SingleCelSingnalR)
Cell_line_mapping <- 1:length(unique(sobj@meta.data$Cell_line))
names(Cell_line_mapping) <- unique(sobj@meta.data$Cell_line)

sobj@meta.data$Cell_line_ID <- unlist(sapply(sobj@meta.data$Cell_line, simplify = FALSE, USE.NAMES = FALSE, function(x){
  Cell_line_mapping[x]
}))

if(FALSE){
  ## make for loop over all cell lines (full data to big)
  res_list <- list()
  for(i in unique(sobj@meta.data$Cell_line)){
    print(i)
    object <- subset(sobj, Cell_line == i)
    ## get cancer type
    ct <- unique(object@meta.data$Cancer_type)
    #cluster = object@meta.data$Cell_line_ID
    cluster = rep(1, length(object$Cell_line))
    data=data.frame(object[['RNA']]@data)
    ## set s.score to 0 to keep all results, better for robust rank aggregation
    signal=cell_signaling(data=data,genes=row.names(object),cluster=cluster,int.type = "autocrine", species = "homo sapiens", s.score = 0, write = FALSE)
    signal <- as.data.frame(unlist(signal, recursive = FALSE)) %>% mutate(Cell_line = i, Cancer_type = ct)
    res_list[[i]] <- signal
    
  }
  saveRDS(res_list, "./../local/signal_list.rds")
}

res_list <- readRDS("./../local/signal_list.rds") 

res <- do.call(rbind, res_list) %>% remove_rownames(.) %>% rename(
  ligand = cluster.1.cluster.1.cluster.1,
  receptor = cluster.1.cluster.1.cluster.1.1,
  score = cluster.1.cluster.1.LRscore, type = cluster.1.cluster.1.interaction.type) %>% mutate(ID = paste0(ligand, "_", receptor))

## summarise amount of autocrine signaling based on cell line

DF_stats <- res %>% group_by(Cell_line, Cancer_type) %>% summarise(n = n())

DT::datatable(DF_stats)

ggplot(DF_stats, aes(Cancer_type ,n, fill = Cell_line)) +
    geom_bar(stat = "sum", position = "stack") + theme_bw() +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
          legend.position = "none") +
    scale_fill_manual(values=c(rep(kelly()[2:length(kelly())], 20))) + 
    labs(title = "Number of infered communication by cancer type (colored by cell line)")

#### aggregate results over all cell lines (find commonly found communications in cancer)
aggregate_ranks <- function(ranked_list){
    # aggregate ranks
    agg_ranks <- aggregateRanks(ranked_list, method = "RRA")
    rownames(agg_ranks) <- NULL
    # correct for multiple testing  doi:10.1093/bioinformatics/btr709. 
    # The initial create scores ar minimal bounds for p-values, Bonferroni correct by multiplby scores * length(ranked_list) to get upper bound.
    # Then correct for multiple testing for each performed test (ID)
    agg_ranks$Score.adj <- agg_ranks$Score * length(ranked_list)
    agg_ranks$Score.adj <- p.adjust(agg_ranks$Score.adj, "BH")
    agg_ranks <- agg_ranks %>% rename(ID = Name)
    return(agg_ranks)
}


ranked_list <- lapply(setNames(unique(res$Cell_line),unique(res$Cell_line)), function(i){
  r <- res %>% filter(Cell_line == i) %>% arrange(desc(score));
  r$ID
})

agg_res <- aggregate_ranks(ranked_list)

DT::datatable(agg_res)

## aggregate ranks only for prostate cancer lines (LNCAPCLONEFGC, PC3)

ranked_list <- lapply(setNames(c("LNCAPCLONEFGC", "PC3"),c("LNCAPCLONEFGC", "PC3")), function(i){
  r <- res %>% filter(Cell_line == i) %>% arrange(desc(score));
  r$ID
})

agg_res <- aggregate_ranks(ranked_list)
# no significant results for aggregation!
DT::datatable(agg_res)


```

